/**
 * segment - A little JavaScript class (without dependencies) to draw and animate SVG path strokes
 * @version v0.0.2
 * @link https://github.com/lmgonzalves/segment
 * @license MIT
 */
function Segment(n, t, i) { this.path = n; this.length = n.getTotalLength(); this.path.style.strokeDashoffset = 2 * this.length; this.begin = t ? this.valueOf(t) : 0; this.end = i ? this.valueOf(i) : this.length; this.timer = null; this.draw(this.begin, this.end) } Segment.prototype = { draw: function (n, t, i, r) { if (i) { var f = r.hasOwnProperty("delay") ? 1e3 * parseFloat(r.delay) : 0, e = r.hasOwnProperty("easing") ? r.easing : null, o = r.hasOwnProperty("callback") ? r.callback : null, u = this; if (this.stop(), f) return delete r.delay, this.timer = setTimeout(function () { u.draw(n, t, i, r) }, f), this.timer; var c = new Date, l = 1e3 / 60, s = this.begin, h = this.end, a = this.valueOf(n), v = this.valueOf(t); !function y() { var r = new Date, f = (r - c) / 1e3, t = f / parseFloat(i), n = t; return "function" == typeof e && (n = e(n)), t > 1 ? (u.stop(), n = 1) : u.timer = setTimeout(y, l), u.begin = s + (a - s) * n, u.end = h + (v - h) * n, u.begin < 0 && (u.begin = 0), u.end > u.length && (u.end = u.length), u.begin < u.end ? u.draw(u.begin, u.end) : u.draw(u.begin + (u.end - u.begin), u.end - (u.end - u.begin)), t > 1 && "function" == typeof o ? o.call(u.context) : void 0 }() } else this.path.style.strokeDasharray = this.strokeDasharray(n, t) }, strokeDasharray: function (n, t) { return this.begin = this.valueOf(n), this.end = this.valueOf(t), [this.length, this.length + this.begin, this.end - this.begin].join(" ") }, valueOf: function (n) { var i = parseFloat(n), t; return ("string" == typeof n || n instanceof String) && ~n.indexOf("%") && (~n.indexOf("+") ? (t = n.split("+"), i = this.percent(t[0]) + parseFloat(t[1])) : ~n.indexOf("-") ? (t = n.split("-"), i = this.percent(t[0]) - parseFloat(t[1])) : i = this.percent(n)), i }, stop: function () { clearTimeout(this.timer); this.timer = null }, percent: function (n) { return parseFloat(n) / 100 * this.length } };
